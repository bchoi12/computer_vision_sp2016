
#include <fstream>
#include <iostream>
#include <vector>

#include "opencv2/highgui.hpp"
#include "opencv2/imgproc.hpp"

#define DEFAULT_WIDTH 300
#define END_HEADER "end_header"
#define THRESHOLD 0.25

void split(const std::string &s, std::vector<std::string> &elems);
void writePPM(cv::Mat &map, std::string outputName, int mapMax = 1);
void rotate(cv::Mat& src, double angle, cv::Mat& dst);

int main(int argc, char** argv) {

  if (argc < 2) {
    printf("Usage: rotate fname [width]\n\tfname: input ply in ascii format\n\twidth: width of initial image\n");
    return 1;
  }

  char* fname = argv[1];
  int width = DEFAULT_WIDTH;
  
  if (argc > 2) {
    width = atoi(argv[2]);
  }
  
  int vertices = 0, faces = 0, edges = 0;
  printf("Reading from file %s\n", fname);
  std::ifstream ifs(fname);

  std::vector<float> vx, vy, vz;
  float xmax, ymax, zmax, xmin, ymin, zmin;
  if (ifs.is_open()) {
    std::string line;
    std::vector<std::string> tokens;
    do {
      std::getline(ifs, line);
      split(line, tokens);

      if (tokens[0] == "element") {
	if (tokens[1] == "vertex") {
	  vertices = atoi(tokens[2].c_str());
	} else if (tokens[1] == "face") {
	  faces = atoi(tokens[2].c_str());
	} else if (tokens[1] == "edge") {
	  edges = atoi(tokens[2].c_str());
	}
      }
    }
    while(line != END_HEADER);

    vx.resize(vertices);
    vy.resize(vertices);
    vz.resize(vertices);
    for(unsigned int i=0; i<vertices; ++i) {
      std::getline(ifs, line);
      split(line, tokens);
      vx[i] = atof(tokens[0].c_str());
      vy[i] = atof(tokens[1].c_str());
      vz[i] = atof(tokens[2].c_str());

      if (i == 0) {
	xmax = vx[i]; xmin = vx[i];
	ymax = vy[i]; ymin = vy[i];
	zmax = vz[i]; zmin = vz[i];
      } else {
	xmax = std::max(vx[i], xmax); xmin = std::min(vx[i], xmin);
	ymax = std::max(vy[i], ymax); ymin = std::min(vy[i], ymin);
	zmax = std::max(vz[i], zmax); zmin = std::min(vz[i], zmin);
      }
    }
  }
  ifs.close();

  int height = width * (ymax - ymin) / (xmax - xmin);

  int maxDensity = 0;
  cv::Mat density = cv::Mat_<int>(height, width);
  for(unsigned int i=0; i<vx.size(); ++i) {
    int xindex, yindex;
    xindex = std::min((int) ((vx[i] - xmin) / (xmax - xmin) * width), (int) width-1);
    yindex = std::min((int) ((vy[i] - ymin) / (ymax - ymin) * height), (int) height-1);

    density.at<int>(yindex, xindex)++;
    maxDensity = std::max((int) density.at<int>(xindex, yindex), maxDensity);
  }

  writePPM(density, "density_map", maxDensity);

  cv::Mat walls = cv::Mat_<bool>(height, width);
  cv::Mat freespace = cv::Mat_<bool>(height, width);

  for(unsigned int i=0; i<walls.rows; ++i) {
    for(unsigned int j=0; j<walls.cols; ++j) {
      walls.at<bool>(i, j) = density.at<int>(i, j) > THRESHOLD * maxDensity ? 1 : 0;
      freespace.at<bool>(i, j) = density.at<int>(i, j) == 0 ? false : !walls.at<bool>(i, j);
    }
  }

  writePPM(walls, "walls");
  writePPM(freespace, "freespace");

  cv::Mat walls_img = cv::imread("walls.ppm");
  
  return 1;
  
  cv::Mat walls_img;// = cv::imread("walls.ppm");
  cv::Mat walls_gray = cv::imread("walls.ppm", CV_LOAD_IMAGE_GRAYSCALE);
  cv::Mat freespace_img;// = cv::imread("freespace.ppm");

  std::vector<cv::Vec4i> lines;
  cv::HoughLinesP(walls_gray, lines, 1, CV_PI/180, 10, 5, 3);

  cv::imshow("walls_gray", walls_gray);

  printf("\n##hough##\n\n");
  
  std::vector<float> angles(lines.size());
  float avgAngle = 0;
  for(unsigned int i=0; i<lines.size(); ++i) {
    float x = lines[i][3] - lines[i][1];
    float y = lines[i][2] - lines[i][0];
    angles[i] = abs(x) < 1e-6 ? CV_PI/2 : atan(y/x);

    //printf("%d: %f\n", i, angles[i]);
    
    avgAngle += angles[i];
  }

  avgAngle /= angles.size();

  float mainAngle = 0, perpAngle = 0;
  int numMain = 0, numPerp = 0;

  for(unsigned int i=0; i<angles.size(); ++i) {
    if (angles[i] > avgAngle) {
      mainAngle += angles[i];
      numMain++;
    } else {
      perpAngle += angles[i];
      numPerp++;
    }
  }

  if (numMain >= numPerp) {
    mainAngle /= numMain;
    perpAngle = mainAngle - CV_PI/2;
  } else {
    perpAngle /= numPerp;
    mainAngle = perpAngle;
    perpAngle = mainAngle - CV_PI/2;
  }
  
  printf("\n##rotate##\n\n");

  printf("Main angle: %f\nPerp angle: %f\n", mainAngle, perpAngle);
  
  cv::Mat rot_walls, rot_freespace;
  rotate(walls_img, -mainAngle*180/CV_PI, rot_walls);
  rotate(freespace_img, -mainAngle*180/CV_PI, rot_freespace);
  
  printf("Rows: %d\nCols: %d\n", rot_freespace.rows, rot_freespace.cols);

  cv::imshow("asdf", rot_freespace);
  cv::waitKey(0);
  
}

void split(const std::string &s, std::vector<std::string> &elems) {
  elems.clear();
  std::stringstream ss(s);
  std::string item;
  while (std::getline(ss, item, ' ')) {
    elems.push_back(item);
  }
}

void writePPM(cv::Mat& map, std::string outputName, int mapMax) {
  const unsigned int mapHeight = map.rows; const unsigned int mapWidth = map.cols;

  if (mapWidth == 0 || mapHeight == 0) {
    return;
  }
  
  outputName += ".ppm";
  
  FILE *fp = fopen(outputName.c_str(), "wb");
  fprintf(fp, "P6\n%d %d\n255\n", mapWidth, mapHeight);
  for(unsigned int i=0; i<mapHeight; ++i) {
    for(unsigned int j=0; j<mapWidth; ++j) {
      static unsigned char color[3];
      color[0] = (mapMax == 1 ? 255*map.at<bool>(i, j) : 255*map.at<int>(i, j) / mapMax);
      color[1] = color[0];
      color[2] = color[0];
      fwrite(color, 1, 3, fp);
    }
  }

  fclose(fp);
}

void rotate(cv::Mat& src, double angle, cv::Mat& dst)
{
  int len = std::sqrt(src.cols*src.cols + src.rows*src.rows);

  dst = cv::Mat(cv::Size(len, len), src.type());

  cv::Mat t = (cv::Mat_<double>(2, 3) << 1, 0, (len-src.cols)/2, 0, 1, (len-src.rows)/2);
  cv::warpAffine(src, dst, t, dst.size());

  cv::Point2f pt(len/2., len/2.);
  cv::Mat r = cv::getRotationMatrix2D(pt, angle, 1.0);

  cv::warpAffine(dst, dst, r, dst.size());

  cv::cvtColor(dst, dst, CV_BGR2GRAY);
  cv::threshold(dst, dst, 100, 255, cv::THRESH_BINARY);
}
